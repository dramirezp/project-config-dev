- builder:
    name: gerrit-git-prep
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net"

- builder:
    name: branch-git-prep
    builders:
      - shell: |
          #!/bin/bash
          export BRANCH={branch}
          /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net

- builder:
    name: revoke-sudo
    builders:
      - shell: |
          #!/bin/bash -x
          sudo rm -f /etc/sudoers.d/jenkins-sudo
          # Prove that general sudo access is actually revoked
          ! sudo -n true

- builder:
    name: ops-distclean
    builders:
      - shell: |
          #!/bin/bash -x
          if test -f Makefile ; then make distclean ; fi

- builder:
    name: yaml-lint
    builders:
      - shell: /usr/local/jenkins/slave_scripts/yamllint.py {file}

- builder:
    name: yaml-verifyall
    builders:
      - shell: |
          #!/bin/bash
          cp -rf jenkins/scripts/yamllint.py .
          chmod +x yamllint.py
          for i in `find . -name *.yaml`; do
            python yamllint.py $i > test
            if grep -q FAIL test; then
               echo " === $i is bad ==="
               exit 1
            else
               cat test
            fi
          done

- builder:
    name: ops-build
    builders:
      - shell: |
          #!/bin/bash -x
          if [ {platform} == "p4" ]
          then
              echo "p4" > .platform_in_archive
              make configure genericx86-64
          else
              make configure {platform}
              echo {platform} > .platform_in_archive
          fi
          BUILD_NUMBER=$(date -u +"%Y%m%d%H")
          export SSTATE_DIR=/mnt/jenkins/workspace/sstate-cache
          mkdir -p /mnt/jenkins/workspace/sstate-cache
          BUILD_VERSION=$(cat yocto/openswitch/meta-distro-openswitch/conf/distro/openswitch.conf | grep 'DISTRO_VERSION =' | cut -d\" -f 2)
          echo "ops-$BUILD_VERSION-$BRANCH+$BUILD_NUMBER" > .version_string
          if [ {platform} == "p4" ]
          then
              make build/conf/local.conf
              echo "EXTRA_IMAGE_FEATURES += \"ops-p4\"" >> build/conf/local.conf
          else
              echo ""
          fi
          make

- builder:
    name: ops-build-tag
    builders:
      - shell: |
          #!/bin/bash -x
          make configure {platform}
          BUILD_NUMBER=$(date -u +"%Y%m%d%H")
          export SSTATE_DIR=/mnt/jenkins/workspace/sstate-cache
          mkdir -p /mnt/jenkins/workspace/sstate-cache
          echo "ops-$tag_v-$BRANCH" > .version_string
          make

- builder:
    name: ops-meta-ide
    builders:
      - shell: |
          make bake meta-ide-support

- builder:
    name: shared-states

    builders:
      - shell: |
          #!/bin/bash -x
          echo "Synchronizing shared states"
          cd /mnt/jenkins/workspace/sstate-cache
          rsync --ignore-existing --exclude='*.done' --size-only -avzL -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" --progress ?? `lsb_release -s -i`-`lsb_release -s -r` static.openswitch.net:/srv/static/sstate || true

- builder:
    name: download-caches

    builders:
      - shell: |
          #!/bin/bash -x
          echo "Synchronizing download archive"
          cd build/downloads
          rsync --size-only -avz -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" --progress *.tar.* *.zip --exclude=*.done static.openswitch.net:/srv/static/archive || true

- builder:
    name: module-build

    builders:
      - shell: |
           #!/bin/bash -x
           set -e

           if [[ ! -e .git ]]; then
             # Remove any content, otherwise the clone will fail
             rm -Rf *
             git clone https://git.openswitch.net/openswitch/ops-build .
           else
             git pull
           fi
           if [ ! -f .platform ] ; then
             make configure {platform}
             export SSTATE_DIR=/mnt/jenkins/workspace/sstate-cache
             mkdir -p /mnt/jenkins/workspace/sstate-cache
           fi
           if grep -q {module} .devenv ; then
             make devenv_rm {module}
           fi
           mkdir -p src/{module}
           cd src/{module}
           /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net
           git diff-tree --no-commit-id --name-only -r refs/heads/master > extension.txt
           cd ../..
           # Trigger building of some basic recipe to get the recipe environment working, since devtool is not that good yet...
           make bake cmake-native
           make devenv_import {module} $PWD/src/{module}
           make bake {module}

- builder:
    name: module-build-branch

    builders:
      - shell: |
           #!/bin/bash -x
           set +x
           # Remove the devenv if previously existed, otherwise if the recipe change version we will have conflicts
           if grep -q {module} .devenv ; then
             make devenv_rm {module}
           fi

           # Identify the branch to use for the build system
           if git ls-remote https://git.openswitch.net/openswitch/ops-build | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BUILD_BRANCH=$ZUUL_BRANCH
           else
             OPS_BUILD_BRANCH=master
           fi
           echo "===================  Building ops-build on $OPS_BUILD_BRANCH =================== "

           set -e
           # If we already have a git repo, avoid nuking them to save build time
           if [[ ! -e .git ]]; then
           # I am temp adding this to resolve issue: fatal: A branch named 'feature/intervlan' already exists."
             rm -fr .[^.]* *
             git clone -b $OPS_BUILD_BRANCH https://git.openswitch.net/openswitch/ops-build .
           else
             # Move to master branch
             git reset --hard
             git checkout master
             git pull
             if [ "$OPS_BUILD_BRANCH" != "master" ] ; then
               # If the branch already existed, remove it
               if git branch | grep -wq $OPS_BUILD_BRANCH  ; then
                 git branch -D $OPS_BUILD_BRANCH
               fi
               git checkout -b $OPS_BUILD_BRANCH --track origin/$OPS_BUILD_BRANCH
             fi
           fi

           # Setup the shared state local cache
           export SSTATE_DIR=/mnt/jenkins/workspace/sstate-cache
           mkdir -p /mnt/jenkins/workspace/sstate-cache

           # Check if we need to configure
           if [ ! -f .platform ] ; then
             make configure {platform}
           fi

           # Import and build module
           mkdir -p src/{module}
           cd src/{module}
           /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net
           git diff-tree --no-commit-id --name-only -r refs/heads/master > extension.txt
           cd ../..
           # Trigger building of some basic recipe to get the recipe environment working, since devtool is not that good yet...
           make bake cmake-native
           make devenv_import {module} $PWD/src/{module}
           make bake {module}

- builder:
    name: feature-cttest-for-ops-build
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           if git ls-remote https://git.openswitch.net/openswitch/ops | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BRANCH=$ZUUL_BRANCH
           else
             OPS_BRANCH=master
           fi
           rm -rf build/*-test-results.xml
           if [ {platform} == "genericx86-64" ] || [ {platform} == "p4" ]
           then
             cd $WORKSPACE
             export VSI_IMAGE_NAME=$(echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]')
             echo $VSI_IMAGE_NAME > .image_name
             make export_docker_image $VSI_IMAGE_NAME

             rm -rf src/ops
             echo "===================  Using Feature Tests from ops:$OPS_BUILD_BRANCH =================== "
             git clone -b $OPS_BRANCH https://git.openswitch.net/openswitch/ops src/ops
             # Usually devenv_import initialized the devenv, but here we use a trick instead
             touch .devenv
             make devenv_ct_init
             make devenv_ct_test PY_TEST_ARGS="src/ops/tests --exitfirst --junit-xml=build/feature-test-results.xml" || (make devenv_ct_clean; docker rmi -f $VSI_IMAGE_NAME)
             test -e .sandbox_uuid && make devenv_ct_clean
             docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
             sudo chown jenkins.jenkins build/*-test-results.xml
           else
             echo "Skipping cttest because of one of reasons: 1. Not a genericx86-64 platform; 2. Commit files are all in .md extension"
           fi

- builder:
    name: feature-cttest
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           rm -rf build/*-test-results.xml
           cd src/{module}
           cat extension.txt
           #if [ {platform} == "genericx86-64" ] && ([ "$(wc -l < extension.txt | bc)" != "$(grep -c "\.md" extension.txt)" ] || [ ! -s extension.txt ])
           if [ {platform} == "genericx86-64" ]
           then
             cd $WORKSPACE
             make fs
             make devenv_ct_init
             y=`echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]'`
             export VSI_IMAGE_NAME=$y
             #echo $VSI_IMAGE_NAME > .sandbox_uuid
             echo $VSI_IMAGE_NAME > .image_name
             make export_docker_image $VSI_IMAGE_NAME
             make devenv_ct_test PY_TEST_ARGS="src/ops/tests --exitfirst --junit-xml=build/feature-test-results.xml" || (make devenv_ct_clean; docker rmi -f $VSI_IMAGE_NAME)
             test -e .sandbox_uuid && make devenv_ct_clean
             docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
             sudo chown jenkins.jenkins build/*-test-results.xml
           else
             echo "Skipping cttest because of one of reasons: 1. Not a genericx86-64 platform; 2. Commit files are all in .md extension"
           fi

- builder:
    name: ops-selfservice-cit-ondemand
    builders:
      - shell: |
           #!/bin/bash -x
           set +x
           # Identify the branch to use for the build system
           if git ls-remote https://git.openswitch.net/openswitch/ops-build | grep -swq "$Feature_BranchName" ; then
              echo "Checking if $Feature_BranchName exists in ops-build repository"
              OPS_BUILD_BRANCH=$Feature_BranchName
           else
              echo "****************************************************************************************"
              echo "WARNING: cannot find $Feature_BranchName in ops-build"
              echo "Please provide a Feature Branch name that exists and try again."
              echo "****************************************************************************************"
              echo "Here are the list of Feature Branches available"
              git ls-remote https://git.openswitch.net/openswitch/ops-build | grep -i "Feature"
              exit 1
           fi
           echo "===================  Building ops-build on $OPS_BUILD_BRANCH =================== "
           rm -fr .[^.]* *
           git clone -b $OPS_BUILD_BRANCH https://git.openswitch.net/openswitch/ops-build .
           # Setup the shared state local cache
           export SSTATE_DIR=/mnt/jenkins/workspace/sstate-cache
           mkdir -p /mnt/jenkins/workspace/sstate-cache
           # Check if we need to configure
           if [ ! -f .platform ] ; then
             make configure genericx86-64
           fi

           set -e
           # clean up .xml
           rm -rf build/*-test-results.xml
           # Prepare the test environment
           touch .devenv
           make testenv_init
           export TOPOLOGY_TEST_IMAGE=$(echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]')
           # testenv_run will:
           # build the fs, export into docker, and download the repos and run the tests
           # The logic below will first runCT in all repos followed by all FT.
           make testenv_run component $(echo $Repositories_List | sed -e 's#,# #g')
           make testenv_rerun feature $(echo $Repositories_List | sed -e 's#,# #g')
           # Cleanup
           test -e .sandbox_uuid && make devenv_ct_clean
           /usr/local/jenkins/slave_scripts/docker_clean_instances_and_image.sh $TOPOLOGY_TEST_IMAGE
           sudo chown jenkins.jenkins build/test/legacy/test-results.xml

- builder:
    name: fttest-for-image
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           if [ {platform} == "genericx86-64" ]
           then
             rm -rf src/ops
             git clone https://git.openswitch.net/openswitch/ops src/ops
             make bake cmake-native
             make devenv_import ops $PWD/src/ops
             make bake ops
             make fs
             make devenv_ct_init
             y=`echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]'`
             export VSI_IMAGE_NAME=$y
             #echo $VSI_IMAGE_NAME > .sandbox_uuid
             echo $VSI_IMAGE_NAME > .image_name
             make export_docker_image $VSI_IMAGE_NAME
             make devenv_ct_test PY_TEST_ARGS="src/ops/tests --exitfirst --junit-xml=build/feature-test-results.xml" || ( make devenv_ct_clean && docker rmi -f $VSI_IMAGE_NAME )
             test -e .sandbox_uuid && make devenv_ct_clean
             docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
           else
             echo "Not a genericx86-64 platform, skipping fttest"
           fi

- builder:
    name: copy-autotestJunitResults
    builders:
      - conditional-step:
          condition-kind: and
          condition-operand:
          condition-kind: file-exists
          condition-filename: build/feature-test-results.xml
          condition-basedir: workspace
          steps:
            - shell: |
                 VERSION_STRING=$(cat .version_string)
                 mkdir -p genericx86-64_autotestJunitResults
                 cp build/feature-test-results.xml genericx86-64_autotestJunitResults/
                 echo ${BUILD_URL}/${BUILD_NUMBER}/testReport/ > genericx86-64_autotestJunitResults/Readme.txt
                 cp -rf genericx86-64_autotestJunitResults $TYPE/$VERSION_STRING/

- builder:
    name: lcov-coverage-run
    builders:
      - shell: |
            #!/bin/bash -x
            # Configuration
            COV_CONF_FILE="src/{module}/ft_ct_coverage"        # Configuration file. If it exists then CT/FT coverage will be performed.
            COV_MINIMUM=-1                                     # Minimum default of coverage.
            COV_REPORT_DIR="coverage"                          # Location where the coverage report data will be placed
            COV_DATA_DIR="src/{module}/"                       # Repo directory where coverage data will be stored (gcda && gcno)
            # If the COV_CONF_FILE does not exist, do not continue, i.e no coverage enabled at the repo.
            if [ -f $COV_CONF_FILE ]
            then
              # Causes a new image to be compiled, repos in src/ (devenv) will be compiled with coverage flags
              make fs
              make devenv_ct_init
              # Export the location where the coverage data has to be placed (.gcda and .gcno files).
              export VSI_COV_DATA_DIR=$PWD/$COV_DATA_DIR
              export VSI_IMAGE_NAME=`echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]'`
              # Remove image, if existing
              docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
              make export_docker_image $VSI_IMAGE_NAME
              # Create coverage data baseline
              rm -rf $COV_REPORT_DIR
              mkdir -p $COV_REPORT_DIR
              lcov --zerocounters --directory $COV_DATA_DIR       # Clear all coverage counters before running the tests
              lcov --initial --capture --directory $COV_DATA_DIR --output-file $COV_REPORT_DIR/app_base.info
              # Run the Component and Feature Tests
              # NOTE: It has been configured to NOT exit on first failure. We want all tests to run to get most possible coverage.
              make devenv_ct_test PY_TEST_ARGS="src/{module}/tests --junit-xml=build/component-test-results.xml"
              # TODO: Enable FT
              # make devenv_ct_test PY_TEST_ARGS="src/ops --junit-xml=build/feature-test-results.xml"
              test -e .sandbox_uuid && make devenv_ct_clean
              # Remove image
              docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
              # Stop debugging to make report output clearer
              set +x
              # Capture the coverage raw data and check that coverage data was generated
              COV_RAW_DATA=`lcov --capture --directory $COV_DATA_DIR --output-file $COV_REPORT_DIR/app_test.info 2>&1`
              if grep -q "ERROR: no \.gcda files found" <<< $COV_RAW_DATA; then
                echo "WARNING: No coverage data was generated during test run. Exiting now with no coverage report"
                exit 0
              fi
              LCOV_COV_FILE="app_total.info"        # The file where the coverage data will be placed
              # Read the configured minimum coverage percentage and exclude patterns from the repo conf file
              # Configure exclude patterns using wildcars and separated by spaces, e.g to remove gtest and openvswitch files use:
              # Exclude_pattern=*gtest* *openvswitch*
              while read -r line
              do
                tmp=`echo "$line" | sed -rn 's/^Minimum_coverage=([0-9]+)$/\1/p'`
                if [ ! -z "$tmp" ]
                then
                  COV_MINIMUM=$tmp
                fi
                tmp=`echo "$line" | sed -rn 's/^Exclude_pattern=(.*)$/\1/p'`
                if [ ! -z "$tmp" ]
                then
                  COV_EXCLUDE_PATTERN=$tmp
                fi
              done < "$COV_CONF_FILE"
              # Check if exclusion pattern is configured and apply it.
              if [ ! -z "$COV_EXCLUDE_PATTERN" ]
              then
                echo "The configured FT/CT code coverage exclude pattern is: $COV_EXCLUDE_PATTERN"
                echo "Going to exclude files from report:"
                lcov --remove $COV_REPORT_DIR/app_base.info $COV_EXCLUDE_PATTERN --output-file $COV_REPORT_DIR/data_base.info
                lcov --remove $COV_REPORT_DIR/app_test.info $COV_EXCLUDE_PATTERN --output-file $COV_REPORT_DIR/data_test.info
                COV_RESULT=`lcov --add-tracefile $COV_REPORT_DIR/data_base.info --add-tracefile $COV_REPORT_DIR/data_test.info --output-file $COV_REPORT_DIR/$LCOV_COV_FILE`
              else
                COV_RESULT=`lcov --add-tracefile $COV_REPORT_DIR/app_base.info --add-tracefile $COV_REPORT_DIR/app_test.info --output-file $COV_REPORT_DIR/$LCOV_COV_FILE`
              fi
              echo "*** Going to merge baseline data with raw coverage data. ***"
              echo "Coverage result after merging with baseline data:"
              echo $COV_RESULT
              # Get actual coverage from command output
              COV_REPORTED=`echo "$COV_RESULT" | sed -rn 's/lines\.\.\.\.\.\.:[[:space:]]([[:digit:]]+).*/\1/p'`
              if [ -z "$COV_REPORTED" ]
              then
                COV_REPORTED=0
              fi
              # Generate the HTML report
              mkdir -p $COV_REPORT_DIR/html
              cd $COV_REPORT_DIR/html
              # TODO: Enable Branch Analysis
              echo "Creating HTML report"
              genhtml --no-branch-coverage ../$LCOV_COV_FILE > /dev/null 2>&1
              cd ../..
              echo ""
              echo "**** Configuration and result info: ****"
              echo ""
              echo "The configured coverage threshold is: $COV_MINIMUM"
              echo "The configured FT/CT code coverage exclude pattern is: $COV_EXCLUDE_PATTERN"
              echo "The actual reported coverage is: $COV_REPORTED"
              echo ""
              if [ "$COV_MINIMUM" -gt "$COV_REPORTED" ]
              then
                echo "The code does not have enough coverage"
                # TODO: Re-enable exit 1.
                # This is being disabled right now because on first stage of
                # the coverage analysis implementation we do not want to
                # block commits based on low coverage.
                # This will be re-enabled later on to prevent low coverage
                # commits from passing.
                # exit 1
                exit 0
              else
                exit 0
              fi
            else
              touch build/dummytest.xml
              echo "Code coverage not enabled or unsupported platform, skipping..."
            fi

- builder:
    name: check-docker-state
    builders:
      - shell: |
           # Check docker containers and images before starting test
           #!/bin/bash -x
           set +e
           docker version
           if [ $? != 0 ]
           then
             echo "Docker command failed. Check if docker daemon is running."
           else
             docker ps -a
             docker images
             # Cleanup docker containers and images before starting test
             # WARN: This job needs to be modified when multiple gate jobs
             #       start running on the same slave
             containers=$(docker ps -aq)
             if [ -z $containers ]
             then
               echo "No containers from previous runs"
             else
               docker stop --time=5 $containers
               docker rm -f $containers
             fi
             images=$(docker images -f "dangling=true" -q)
             if [ -z $images ]
             then
               echo "No dangling docker images"
             else
               docker rmi -f $images
             fi
             images=$(docker images | grep '^ops.*' | awk '{print $1}')
             if [ -z $images ]
             then
               echo "No ops images from previous runs"
             else
               docker rmi -f $images
             fi
             echo "After docker cleanup"
             docker ps -a
             docker images
           fi

- builder:
    name: clear-test-logs
    builders:
      - shell: |
           #!/bin/bash -x
           set +e
           # Clear test execution logs from previous runs
           ls /tmp/openswitch-test
           if [ $? != 0 ]
           then
             echo "No previous test logs from ops-vsi."
           else
             sudo chown -R jenkins.jenkins /tmp/openswitch-test
             sudo rm -rf /tmp/openswitch-test/
           fi
           ls /tmp/opsTest-results
           if [ $? != 0 ]
           then
             echo "No previous test logs from ops-ft-framework."
           else
             sudo chown -R jenkins.jenkins /tmp/opsTest-results
             sudo rm -rf /tmp/opsTest-results/
           fi
           rm -Rf build/*_syslog.txt

- builder:
    name: module-test-no-feature
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           if git ls-remote https://git.openswitch.net/openswitch/ops | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BRANCH=$ZUUL_BRANCH
           else
             OPS_BRANCH=master
           fi
           rm -rf build/test/*/test-results.xml
           cd src/{module}
           cat extension.txt
           if [ {platform} == "genericx86-64" ]
           then
             cd $WORKSPACE
             touch .devenv
             make {module}-clean
             touch build/devenv-coverage-enabled
             make testenv_init
             export TOPOLOGY_TEST_IMAGE=$(echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]')
             # If we have modular component tests, we run them
             SECOND_RUN_COMMAND=testenv_run
             if [ -d src/{module}/ops-tests/component ] ; then
               make testenv_run component {module}
               SECOND_RUN_COMMAND=testenv_rerun
             fi
             # If this module still has legacy component test, we run them too, otherwise only the legacy feature
             if [ -d src/{module}/tests ] ; then
                # build the fs, export into docker, and download the repos and run the tests
                make $SECOND_RUN_COMMAND legacy {module}
             fi
             test -e .sandbox_uuid && make devenv_ct_clean
             /usr/local/jenkins/slave_scripts/docker_clean_instances_and_image.sh $TOPOLOGY_TEST_IMAGE
             sudo chown jenkins.jenkins build/test/*/test-results.xml
           else
             echo "Skipping tests because it is not a genericx86-64 platform"
           fi

- builder:
- builder:
    name: module-test
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           if git ls-remote https://git.openswitch.net/openswitch/ops | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BRANCH=$ZUUL_BRANCH
           else
             OPS_BRANCH=master
           fi
           rm -rf build/test/*/test-results.xml
           cd src/{module}
           cat extension.txt
           if [ {platform} == "genericx86-64" ]
           then
             cd $WORKSPACE
             touch .devenv
             make {module}-clean
             touch build/devenv-coverage-enabled
             make testenv_init
             export TOPOLOGY_TEST_IMAGE=$(echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]')
             # If we have modular component tests, we run them
             SECOND_RUN_COMMAND=testenv_run
             if [ -d src/{module}/ops-tests/component ] ; then
               make testenv_run component {module}
               SECOND_RUN_COMMAND=testenv_rerun
             fi
             # If this module still has legacy component test, we run them too
             if [ -d src/{module}/tests ] ; then
               make $SECOND_RUN_COMMAND legacy {module}
               SECOND_RUN_COMMAND=testenv_rerun
             fi
             # If this module has modular feature test, we run them
             if [ -d src/{module}/ops-tests/feature ] ; then
               make $SECOND_RUN_COMMAND feature {module}
               SECOND_RUN_COMMAND=testenv_rerun
             fi

             # If ops has modular feature test, we run them
             if [ -d src/ops/ops-tests/feature ] ; then
               make $SECOND_RUN_COMMAND feature ops
               SECOND_RUN_COMMAND=testenv_rerun
             fi
             # If ops has legacy feature test, we run them
             if [ -d src/ops/tests ] ; then
               make $SECOND_RUN_COMMAND legacy ops
             fi

             # build the fs, export into docker, and download the repos and run the tests
             test -e .sandbox_uuid && make devenv_ct_clean
             /usr/local/jenkins/slave_scripts/docker_clean_instances_and_image.sh $TOPOLOGY_TEST_IMAGE
             sudo chown jenkins.jenkins build/test/*/test-results.xml
           else
             echo "Skipping tests because it is not a genericx86-64 platform"
           fi

- builder:
    name: module-cttest
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           if git ls-remote https://git.openswitch.net/openswitch/ops | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BRANCH=$ZUUL_BRANCH
           else
             OPS_BRANCH=master
           fi
           rm -rf build/*-test-results.xml
           cd src/{module}
           cat extension.txt
           if [ {platform} == "genericx86-64" ]
           then
             cd $WORKSPACE
             rm -rf src/ops
             echo "===================  Building Feature Tests from ops:$OPS_BUILD_BRANCH =================== "
             git clone -b $OPS_BRANCH https://git.openswitch.net/openswitch/ops src/ops
             make fs
             make devenv_ct_init
             y=`echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]'`
             export VSI_IMAGE_NAME=$y
             echo $VSI_IMAGE_NAME > .image_name
             make export_docker_image $VSI_IMAGE_NAME
             make devenv_ct_test PY_TEST_ARGS="src/{module}/tests --exitfirst --junit-xml=build/module-test-results.xml" || (make devenv_ct_clean; docker rmi -f $VSI_IMAGE_NAME; exit 1)
             make devenv_ct_test PY_TEST_ARGS="src/ops/tests --exitfirst --junit-xml=build/feature-test-results.xml" || (make devenv_ct_clean; docker rmi -f $VSI_IMAGE_NAME; exit 1)
             test -e .sandbox_uuid && make devenv_ct_clean
             docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
             sudo chown jenkins.jenkins build/*-test-results.xml
           else
             echo "Skipping cttest because it is not a genericx86-64 platform"
           fi

- builder:
    name: module-cttest-codecoverage
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           COV_CONF_FILE="src/{module}/ft_ct_coverage"        # Configuration file. If it exists then CT/FT coverage will be performed.
           COV_MINIMUM=80                                        # Minimum default of coverage.
           COV_REPORT_DIR="coverage"                             # Location where the coverage report data will be placed
           COV_DATA_DIR="src/{module}/"                       # Repo directory where coverage data will be stored (gcda && gcno)

           if git ls-remote https://git.openswitch.net/openswitch/ops | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BRANCH=$ZUUL_BRANCH
           else
             OPS_BRANCH=master
           fi
           rm -rf build/*-test-results.xml
           cd src/{module}
           cat extension.txt
           if [ {platform} == "genericx86-64" ]
           then
             cd $WORKSPACE
             rm -rf src/ops
             echo "===================  Building Feature Tests from ops:$OPS_BUILD_BRANCH =================== "
             git clone -b $OPS_BRANCH https://git.openswitch.net/openswitch/ops src/ops
             make fs
             make devenv_ct_init
             y=`echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]'`
             export VSI_IMAGE_NAME=$y
             echo $VSI_IMAGE_NAME > .image_name
             make export_docker_image $VSI_IMAGE_NAME

             if [ -f $COV_CONF_FILE ]
             then
                export VSI_COV_DATA_DIR=$PWD/$COV_DATA_DIR
                rm -rf $COV_REPORT_DIR
                mkdir -p $COV_REPORT_DIR
                lcov --zerocounters --directory $COV_DATA_DIR       # Clear all coverage counters before running the tests
                lcov --initial --capture --directory $COV_DATA_DIR --output-file $COV_REPORT_DIR/app_base.info
             fi

             make devenv_ct_test PY_TEST_ARGS="src/{module}/tests --exitfirst --junit-xml=build/module-test-results.xml" || (make devenv_ct_clean; docker rmi -f $VSI_IMAGE_NAME; exit 1)
             make devenv_ct_test PY_TEST_ARGS="src/ops/tests --exitfirst --junit-xml=build/feature-test-results.xml" || (make devenv_ct_clean; docker rmi -f $VSI_IMAGE_NAME; exit 1)
             test -e .sandbox_uuid && make devenv_ct_clean
             docker images | grep $VSI_IMAGE_NAME && docker rmi -f $VSI_IMAGE_NAME
             sudo chown jenkins.jenkins build/*-test-results.xml

             if [ -f $COV_CONF_FILE ]
             then
                 # TODO: Implement Branch Analysis
                 LCOV_NO_BRANCH="--rc lcov_branch_coverage=0"
                 # Capture the coverage raw data
                 lcov $LCOV_NO_BRANCH --capture --directory $COV_DATA_DIR --output-file $COV_REPORT_DIR/app_test.info
                 LCOV_COV_FILE="app_total.info"        # The file where the coverage data will be placed
                 # Read the configured minimum coverage percentage and exclude patterns from the repo conf file
                 # Configure exclude patterns using wildcars and separated by spaces, e.g to remove gtest and openvswitch files use:
                 # Exclude_pattern=*gtest* *openvswitch*
                 while read -r line
                 do
                   tmp=`echo "$line" | sed -rn 's/^Minimum_coverage=([0-9]+)$/\1/p'`
                   if [ ! -z "$tmp" ]
                   then
                       COV_MINIMUM=$tmp
                   fi
                   tmp=`echo "$line" | sed -rn 's/^Exclude_pattern=(.*)$/\1/p'`
                   if [ ! -z "$tmp" ]
                   then
                     COV_EXCLUDE_PATTERN=$tmp
                   fi
                 done < "$COV_CONF_FILE"

                 # Check if exclusion pattern is configured and apply it.
                 if [ ! -z "$COV_EXCLUDE_PATTERN" ]
                 then
                   lcov --remove $COV_REPORT_DIR/app_base.info $COV_EXCLUDE_PATTERN --output-file $COV_REPORT_DIR/data_base.info
                   lcov --remove $COV_REPORT_DIR/app_test.info $COV_EXCLUDE_PATTERN --output-file $COV_REPORT_DIR/data_test.info
                   COV_RESULT=`lcov $LCOV_NO_BRANCH --add-tracefile $COV_REPORT_DIR/data_base.info --add-tracefile $COV_REPORT_DIR/data_test.info --output-file $COV_REPORT_DIR/$LCOV_COV_FILE`
                 else
                   COV_RESULT=`lcov $LCOV_NO_BRANCH --add-tracefile $COV_REPORT_DIR/app_base.info --add-tracefile $COV_REPORT_DIR/app_test.info --output-file $COV_REPORT_DIR/$LCOV_COV_FILE`
                 fi

                 # Get actual coverage from command output
                 COV_REPORTED=`echo "$COV_RESULT" | sed -rn 's/lines\.\.\.\.\.\.:[[:space:]]([[:digit:]]+).*/\1/p'`
                 if [ -z "$COV_REPORTED" ]
                 then
                    COV_REPORTED=0
                 fi

                 # Generate the HTML report
                 mkdir -p $COV_REPORT_DIR/html
                 cd $COV_REPORT_DIR/html
                 # TODO: Implement Branch Analysis
                 genhtml --no-branch-coverage ../$LCOV_COV_FILE
                 cd ../..

                 echo "The configuration file is: $COV_CONF_FILE"
                 echo "The configured coverage threshold is: $COV_MINIMUM"
                 echo "The configured FT/CT code coverage exclude pattern is $COV_EXCLUDE_PATTERN"
                 echo "The result of the data coverage command is $COV_RESULT"
                 echo "The actual reported coverage is:"
                 echo $COV_REPORTED

                 if [ "$COV_MINIMUM" -gt "$COV_REPORTED" ]
                 then
                      echo "The code does not have enough coverage"
                      echo "The location of the coverage report is: $PWD/$COV_REPORT_DIR/html."
                      exit 1
                 else
                      exit 0
                 fi
             fi

           else
             echo "Skipping cttest"
           fi

- builder:
    name: module-stress-test
    builders:
      - shell: |
           #!/bin/bash -x
           set +e
           MOD_FRAMEWORK="^ops-tests\/(.*?\/)?test_.*?.py$"
           PATTERN="^(.*?\/)?tests\/(.*?\/)?test_.*?.py$"
           TEST_FAILURE=0
           EXIT_FLAG=0
           TEST_TYPE=""

           if git ls-remote https://git.openswitch.net/openswitch/ops | grep -swq "$ZUUL_BRANCH" ; then
             OPS_BRANCH=$ZUUL_BRANCH
           else
             OPS_BRANCH=master
           fi
           rm -rf build/test/*/test-results.xml
           cd src/{module}
           # arr_files=($(git diff-tree --no-commit-id --name-only -r $ZUUL_COMMIT))
           git diff-tree --no-commit-id --name-only -r $ZUUL_COMMIT > incoming_patch.txt
           cat incoming_patch.txt
           if [ {platform} == "genericx86-64" ]
           then
             cd $WORKSPACE
             touch .devenv
             make testenv_init
             export TOPOLOGY_TEST_IMAGE=$(echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]')

             SECOND_RUN_COMMAND=testenv_run
             # for tst in $(git diff-tree --no-commit-id --name-only -r $ZUUL_COMMIT)
             while read -r line
             do
               echo $line
               TEST_FAILURE=0

               if [ ! -f src/{module}/$line ]
               then
                 echo "skipping deleted file"
                 continue
               fi

               if [[ $line =~ $MOD_FRAMEWORK ]];
               then
                 TEST_TYPE="component"
               elif [[ $line =~ $PATTERN ]];
               then
                 TEST_TYPE="legacy"
               else
                 continue
               fi

               test_file=$( echo $line | egrep -o 'test_.*?.py$')
               make $SECOND_RUN_COMMAND $TEST_TYPE {module} TESTENV_ITERATIONS=5 TESTENV_EXTRA_PARAMETERS="-k $test_file"
               if [ $? != 0 ]
               then
                 TEST_FAILURE=1
               fi

               SECOND_RUN_COMMAND=testenv_rerun
               if [ $TEST_FAILURE != 0 ]
               then
                 EXIT_FLAG=1
                 make devenv_ct_clean
                 echo $tst "failed"
               fi
             done < src/{module}/incoming_patch.txt

             if [ $EXIT_FLAG == 1 ]
             then
               docker rmi -f $VSI_IMAGE_NAME
               exit 3
             else
               set -e
               # If we have modular component tests, we run them
               if [ -d src/{module}/ops-tests/component ] ; then
                 make $SECOND_RUN_COMMAND component {module}
                 SECOND_RUN_COMMAND=testenv_rerun
               fi
               # If this module still has legacy component test, we run them too, otherwise only the legacy feature
               if [ -d src/{module}/tests ] ; then
                  TESTS_TO_RUN="{module} ops"
               else
                  TESTS_TO_RUN="ops"
               fi
               # build the fs, export into docker, and download the repos and run the tests
               make $SECOND_RUN_COMMAND legacy $TESTS_TO_RUN
               test -e .sandbox_uuid && make devenv_ct_clean
               /usr/local/jenkins/slave_scripts/docker_clean_instances_and_image.sh $TOPOLOGY_TEST_IMAGE
               sudo chown jenkins.jenkins build/test/*/test-results.xml
             fi
           else
             echo "Skipping tests because it is not a genericx86-64 platform"
           fi

#- builder:
#    name: gulp-dist
#    builders:
#      - shell: |
#           #!/bin/bash -x
#           set -e
#
#           if [[ ! -e .git ]]; then
#             # Remove any content, otherwise the clone will fail
#             rm -Rf *
#             git clone https://git.openswitch.net/openswitch/ops-build .
#           else
#             git pull
#           fi
#           if [ ! -f .platform ] ; then
#             make configure {platform}
#             make build/conf/local.conf
#             mkdir -p /mnt/jenkins/workspace/sstate-cache
#             rm -Rf build/sstate-cache
#             ln -sf /mnt/jenkins/workspace/sstate-cache build/sstate-cache
#           fi
#           make bake node-native
#           export PATH=$PWD/build/tmp/sysroots/x86_64-linux/usr/bin:$PATH
#           if ! [ -d website ] ; then mkdir website ; fi
#           rm -Rf www
#           cd website
#           /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net
#           npm install
#           npm install -g gulp
#           npm install -g grommet
#           gulp dist
#           mv dist ../www

- builder:
    name: gulp-prepare
    builders:
      - shell: |
           #!/bin/bash -x
           set -e

           if [[ ! -e .git ]]; then
             # Remove any content, otherwise the clone will fail
             rm -Rf *
             git clone https://git.openswitch.net/openswitch/ops-build .
           else
             git pull
           fi
           if [ ! -f .platform ] ; then
             make configure {platform}
             SSTATE_DIR=/mnt/jenkins/workspace/sstate-cache
             mkdir -p /mnt/jenkins/workspace/sstate-cache
           fi
           make bake node-native
           export PATH=$PWD/build/tmp/sysroots/x86_64-linux/usr/bin:$PATH
           npm install -g grommet
           npm install -g gulp

- builder:
    name: gulp-install
    builders:
      - shell: |
           #!/bin/bash -x
           set -e
           make bake node-native
           export PATH=$PWD/build/tmp/sysroots/x86_64-linux/usr/bin:$PATH
           npm install -g grommet
           npm install -g gulp

- builder:
    name: get-website-stable
    builders:
      - shell: |
           #!/bin/bash -x
           if [[ ! -d website ]]; then
             git clone https://git.openswitch.net/infra/website website/
           else
             cd website
             git pull
           fi

- builder:
    name: get-website-under-review
    builders:
      - shell: |
           #!/bin/bash -x
           if ! [ -d website ] ; then mkdir website ; fi
           cd website
           /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net

- builder:
    name: get-dev-docs-stable
    builders:
      - shell: |
           #!/bin/bash -x
           cd website/src/markdown/en-US/documents
           if [[ ! -d dev ]]; then
             git clone https://git.openswitch.net/openswitch/ops-docs dev/
           else
             cd dev
             git pull
           fi

- builder:
    name: get-dev-docs-underreview
    builders:
      - shell: |
           #!/bin/bash -x
           cd website/src/markdown/en-US/documents
           if [[ ! -d dev ]]; then
             mkdir dev
           fi
           cd dev
           /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net


- builder:
    name: get-user-docs-stable
    builders:
      - shell: |
           #!/bin/bash -x
           cd website/src/markdown/en-US/documents
           rm -Rf user
           if [[ ! -d temp ]]; then
             git clone https://git.openswitch.net/openswitch/ops temp/
           else
             git pull
           fi
           cd temp
           cp -R docs ../user
           cd ..
           rm -rf temp

- builder:
    name: get-user-docs-underreview
    builders:
      - shell: |
           #!/bin/bash -x
           cd website/src/markdown/en-US/documents
           rm -Rf user
           if [[ ! -d temp ]]; then
             mkdir temp
           fi
           rm -r temp/*
           cd temp
           /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openswitch.net git://git.openswitch.net
           cp -R docs ../user

- builder:
    name: gulp-dist
    builders:
      - shell: |
           #!/bin/bash -x
           export PATH=$PWD/build/tmp/sysroots/x86_64-linux/usr/bin:$PATH
           rm -Rf www
           cd website
           npm install
           gulp dist
           mv dist ../www

- builder:
    name: create-periodic-build-image

    builders:
      - shell: |
          #!/bin/bash -x
          VERSION_STRING=$(cat .version_string)
          PLATFORM=$(cat .platform_in_archive)
          echo "BUILD_ID=\"$PLATFORM-$VERSION_STRING\"" > build/build_info.conf
          make changelog_manifest
          make

- builder:
    name: create-build-artifacts

    builders:
      - shell: |
          #!/bin/bash -x
          VERSION_STRING=$(cat .version_string)
          PLATFORM=$(cat .platform_in_archive)
          rm -Rf $TYPE
          mkdir -p $TYPE/$VERSION_STRING/$PLATFORM
          find images -name "onie-installer*" -exec bash -c "cp \"\$0\" $TYPE/$VERSION_STRING/$PLATFORM/\$(basename \"\$0\")-$VERSION_STRING" {} \;
          find images -name "*.ova" -exec bash -c "cp \"\$0\" $TYPE/$VERSION_STRING/$PLATFORM/\$(basename -s .ova \"\$0\")-$VERSION_STRING.ova" {} \;
          find images -name "*.tar.gz" -exec bash -c "cp \"\$0\" $TYPE/$VERSION_STRING/$PLATFORM/\$(basename -s .tar.gz \"\$0\")-$VERSION_STRING.tar.gz" {} \;
          find images -name "*.manifest" -exec bash -c "cp \"\$0\" $TYPE/$VERSION_STRING/$PLATFORM/\$(basename -s .manifest \"\$0\")-$VERSION_STRING.manifest" {} \;
          cp build/changelog.manifest $TYPE/$VERSION_STRING/$PLATFORM/changelog.manifest
          test -e .version_string && echo $VERSION_STRING > $TYPE/$VERSION_STRING/$PLATFORM/build_v
          cd $TYPE/$VERSION_STRING/$PLATFORM
          for file in $(ls) ; do sha256sum $file > $file.sha256sum ; done
          rename 's/onie-installer/openswitch-onie-installer/' *

- builder:
    name: capture-test-logs
    builders:
      - shell: |
          # Copy ops-vsi test results
          rm -rf openswitch-test
          cp -rf /tmp/openswitch-test/. openswitch-test || true
          # Copy ops-ft-framework test results
          rm -rf opsTest-results
          cp -rf /tmp/opsTest-results/. opsTest-results || true

- builder:
    name: scp-artifacts
    builders:
      - shell: |
          VERSION_STRING=$(cat .version_string)
          PLATFORM=$(cat .platform_in_archive)

          if [ "$PLATFORM" = "p4" ]
          then
            cd $TYPE; scp -r $VERSION_STRING static.openswitch.net:/srv/static/archive/experimental/$TYPE/.
          else
            cd $TYPE; scp -r $VERSION_STRING static.openswitch.net:/srv/static/archive/artifacts/$TYPE/.
          fi

- builder:
    name: scp-artifacts-junit
    builders:
      - conditional-step:
          condition-kind: file-exists
          condition-filename: build/feature-test-results.xml
          on-evaluation-failure: dont-run
          steps:
             - shell: |
                 VERSION_STRING=$(cat .version_string)
                 mkdir -p genericx86-64_autotestJunitResults
                 cp build/feature-test-results.xml genericx86-64_autotestJunitResults/
                 echo ${BUILD_URL}/${BUILD_NUMBER}/testReport/ > genericx86-64_autotestJunitResults/Readme.txt
                 scp -r genericx86-64_autotestJunitResults static.openswitch.net:/srv/static/archive/artifacts/$TYPE/$VERSION_STRING/.

- builder:
    name: coverage
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-cover.sh"

- builder:
    name: docs
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-docs.sh"

- builder:
    name: maven-test
    builders:
      - shell: "mvn test -B"

- builder:
    name: maven-package
    builders:
      - shell: "mvn package -B"

- builder:
    name: gerrit-package
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/package-gerrit.sh"

- builder:
    name: gerrit-preclean
    builders:
      - shell: |
          #!/bin/bash -xe
          rm -fr ~/.m2
          rm -fr ~/.java
          ./tools/version.sh --release

- builder:
    name: gerrit-postrun
    builders:
      - shell: "./tools/version.sh --reset"

- builder:
    name: bashate
    builders:
      - tox:
          envlist: bashate

- builder:
    name: pep8
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-pep8.sh"

- builder:
    name: pylint
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-pylint.sh"

- builder:
    name: npm-install
    builders:
      - shell: |
          sudo apt-get update
          sudo apt-get install -y nodejs nodejs-legacy npm

- builder:
    name: npm-run
    builders:
      - shell: |
          export DISPLAY=:99
          npm install
          npm run {command}

- builder:
    name: xvfb-start
    builders:
      - shell: |
          DIMENSIONS='1280x1024x24'
          /usr/bin/Xvfb :99 -screen 0 ${DIMENSIONS} -ac +extension GLX +render -noreset 2>&1 > /dev/null &

- builder:
    name: xvfb-install
    builders:
      - shell: |
          sudo apt-get update
          sudo apt-get install -y xvfb

- builder:
    name: firefox-install
    builders:
      - shell: |
          sudo apt-get update
          sudo apt-get install -y firefox

- builder:
    name: chrome-install
    builders:
      - shell: |
          sudo apt-get update
          sudo apt-get install -y chromium-browser

- builder:
    name: diskimage-builder-install
    builders:
      - shell: |
          sudo apt-get update
          sudo apt-get install -y qemu kpartx
          sudo pip install dib-utils
          sudo pip install diskimage-builder

- builder:
    name: uninstall-puppet
    builders:
      - shell: "sudo apt-get remove -y --purge facter puppet puppet-common"

- builder:
    name: puppet-lint
    builders:
      - shell: |
          if [ -f Modulefile -o -f metadata.json ]; then
            if [ -f Modulefile ]; then
              MODULE=$(awk '/^name/ {print $NF}' Modulefile |tr -d \"\')
            elif [ -f metadata.json ]; then
              MODULE=$(python -c 'import json;print json.load(open("metadata.json"))["name"]')
            fi
            if [ -z "$MODULE" ]; then
              echo "Module name not defined in Modulefile or metadata.json"
            else
              mkdir -p "$MODULE"
              rsync -a --exclude="$MODULE" --exclude ".*" . "$MODULE"
              cd "$MODULE"
            fi
          fi
          if [ -f Gemfile ]; then
            mkdir .bundled_gems
            export GEM_HOME=`pwd`/.bundled_gems
            bundle install
            bundle exec rake lint 2>&1
          else
            rake lint 2>&1
          fi

- builder:
    name: puppet-syntax
    builders:
      - shell: |
          find . -iname *.pp | xargs puppet parser validate --modulepath=`pwd`/modules
          for f in `find . -iname *.erb` ; do
            erb -x -T '-' $f | ruby -c
          done

# note that this job uses an in-repo script for execution
# in order to cater for differing requirements per branch
- builder:
    name: ansible-check-lint
    builders:
      - shell: |
          #!/bin/bash -xe
          sudo scripts/gate-check-lint.sh

# note that this job uses an in-repo script for execution
# in order to cater for differing requirements per branch
- builder:
    name: ansible-check-commit
    builders:
      - shell: |
          #!/bin/bash -xe
          sudo scripts/gate-check-commit.sh

- builder:
    name: ansible-prep
    builders:
      - shell: |
          #!/bin/bash -xe
          sudo -H pip install -U ansible

- builder:
    name: ansible-syntax
    builders:
      - shell: |
          #!/bin/bash -xe
          cd tests
          ansible-playbook --syntax-check -i inventory test.yml -e rolename=$(basename $(dirname $(pwd)))

- builder:
    name: ansible-lint-prep
    builders:
      - shell: |
          #!/bin/bash -xe
          sudo -H pip install ansible-lint

- builder:
    name: ansible-lint
    builders:
      - shell: |
          #!/bin/bash -xe
          ansible-lint **/*.yml

- builder:
    name: ruby-191-prep
    builders:
      - shell: |
          #!/bin/bash -x
          # Set 1.9.1 ruby and gem as default
          sudo update-alternatives --install /usr/bin/ruby ruby /usr/bin/ruby1.9.1 20
          sudo update-alternatives --set ruby /usr/bin/ruby1.9.1
          sudo update-alternatives --install /usr/bin/gem gem /usr/bin/gem1.9.1 10
          sudo update-alternatives --set gem /usr/bin/gem1.9.1
          sudo gem install bundler --no-rdoc --no-ri --verbose
          sudo gem install rake    --no-rdoc --no-ri --verbose

- builder:
    name: chef-bundler-prep
    builders:
      - shell: |
          #!/bin/bash -x
          mkdir -p .bundle
          grep -E .*berkshelf.*3\.\d*\.\d*.* Gemfile
          if [ $? -eq 0 ]; then
            # For Berkshelf 3.x use the system gecode 3.x libraries
            sudo apt-get update
            sudo apt-get install -y libgecode-dev libxml2-dev libxml2 libxslt-dev build-essential
            USE_SYSTEM_GECODE=1 bundle install --path=.bundle --jobs 1 --retry 3 --verbose
          else
            bundle install --path=.bundle --jobs 1 --retry 3 --verbose
          fi

- builder:
    name: chef-bootstrap
    builders:
      - shell: |
          #!/bin/bash -x
          ./bootstrap.sh

- builder:
    name: chef-rake-test
    builders:
      - shell: |
          #!/bin/bash -x
          chef exec rake

- builder:
    name: chef-berkshelf-prep
    builders:
      - shell: |
          #!/bin/bash -x
          grep -E .*berkshelf.*3\.\d*\.\d*.* Gemfile
          if [ $? -eq 0 ]; then
            bundle exec berks vendor .cookbooks
          else
            mkdir -p .cookbooks
            bundle exec berks install --path=.cookbooks
          fi

- builder:
    name: chef-cookbook-rubocop
    builders:
      - shell: |
          #!/bin/bash -x
          if grep rubocop: Strainerfile; then
              bundle exec strainer test --cookbooks-path=.cookbooks --only=rubocop
          else
              bundle exec rubocop
          fi

- builder:
    name: chef-cookbook-foodcritic
    builders:
      - shell: |
          #!/bin/bash -x
          if grep foodcritic: Strainerfile; then
              bundle exec strainer test --cookbooks-path=.cookbooks --only=foodcritic
          else
              bundle exec foodcritic -f any -t ~FC003 -t ~FC023 .
          fi

- builder:
    name: chef-cookbook-chefspec
    builders:
      - shell: |
          #!/bin/bash -x
          if grep chefspec: Strainerfile; then
              bundle exec strainer test --cookbooks-path=.cookbooks --only=chefspec
          else
              bundle exec rspec --format documentation
          fi

- builder:
    name: run-tests
    builders:
      - shell: "./run-tests.sh"

- builder:
    name: selenium
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-selenium.sh"

- builder:
    name: js-build
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-jsbuild.sh {command}"

- builder:
    name: python26
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-tox.sh py26"

- builder:
    name: python27
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-tox.sh py27"

- builder:
    name: python33
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-tox.sh py33"

- builder:
    name: python34
    builders:
      - shell:  "/usr/local/jenkins/slave_scripts/run-tox.sh py34"

- builder:
    name: pypy
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-tox.sh pypy"

- builder:
    name: tox
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/run-tox.sh {envlist}"

- builder:
    name: assert-no-extra-files
    builders:
      - shell: |
          #!/bin/bash
          OUT=`git ls-files --other --exclude-standard --directory`
          if [ -z "$OUT" ]; then
              echo "No extra files created during test."
              exit 0
          else
              echo "The following un-ignored files were created during the test:"
              echo "$OUT"
              exit 0  # TODO: change to 1 to fail tests.
          fi

- builder:
    name: tarball
    builders:
      - shell: |
          #!/bin/bash -xe
          /usr/local/jenkins/slave_scripts/run-tarball.sh
          /usr/local/jenkins/slave_scripts/run-wheel.sh

- builder:
    name: devstack-checkout
    builders:
      - shell: |
          #!/bin/bash -xe
          if [[ ! -e devstack-gate ]]; then
              git clone git://git.openstack.org/openstack-infra/devstack-gate
          else
              cd devstack-gate
              git remote set-url origin git://git.openstack.org/openstack-infra/devstack-gate
              git remote update
              git reset --hard
              if ! git clean -x -f ; then
                  sleep 1
                  git clean -x -f
              fi
              git checkout master
              git reset --hard remotes/origin/master
              if ! git clean -x -f ; then
                  sleep 1
                  git clean -x -f
              fi
              cd ..
          fi

- builder:
    name: experimental-devstack-checkout
    builders:
      - shell: |
          #!/bin/bash -xe
          if [[ ! -e devstack-gate ]]; then
              git clone git://git.openstack.org/openstack-infra/devstack-gate
          fi
          cd devstack-gate
          /usr/local/jenkins/slave_scripts/gerrit-git-prep.sh https://review.openstack.org git://git.openstack.org
          cd ..

- builder:
    name: link-logs
    builders:
      - shell: |
          #!/bin/sh
          echo "Detailed logs: http://logs.openstack.org/$LOG_PATH/"


- builder:
    name: net-info
    builders:
      - shell: |
          #!/bin/sh
          export PATH=$PATH:/sbin
          echo "Network interface addresses..."
          ip address show
          echo "Network routing tables..."
          ip route show
          ip -6 route show
          echo "Network neighbors..."
          ip neighbor show

- builder:
    name: base-packages-trusty
    builders:
      - shell: |
          #!/bin/bash -xe
          sudo apt-get update
          sudo PATH=/usr/sbin:/sbin:$PATH DEBIAN_FRONTEND=noninteractive \
              apt-get --option "Dpkg::Options::=--force-confold" --assume-yes \
              install \
                  build-essential \
                  python-dev \
                  mysql-client \
                  mysql-server \
                  libmysqlclient-dev \
                  postgresql-client \
                  postgresql \
                  libpq-dev \
                  libffi-dev \
                  libxslt-dev \

- builder:
    name: mysql-prep
    builders:
      - shell: |
          #!/bin/bash -xe
          DB_ROOT_PW=insecure_slave
          DB_USER=openstack_citest
          DB_PW=openstack_citest
          sudo -H mysqladmin -u root password $DB_ROOT_PW
          sudo -H mysql -u root -p$DB_ROOT_PW -h 127.0.0.1 -e "
              GRANT ALL PRIVILEGES ON *.*
                  TO '$DB_USER'@'%' identified by '$DB_PW';"

- builder:
    name: pgsql-prep
    builders:
      - shell: |
          #!/bin/bash -xe
          DB_ROOT_PW=insecure_slave
          DB_USER=openstack_citest
          DB_PW=openstack_citest
          root_roles=$(sudo -H -u postgres psql -t -c "
              SELECT 'HERE' from pg_roles where rolname='$DB_USER'")
          if [[ ${root_roles} == *HERE ]];then
              sudo -H -u postgres psql -c "
                  ALTER ROLE $DB_USER WITH SUPERUSER LOGIN PASSWORD '$DB_PW'"
          else
              sudo -H -u postgres psql -c "
                  CREATE ROLE $DB_USER WITH SUPERUSER LOGIN PASSWORD '$DB_PW'"
          fi
          cat << EOF > $HOME/.pgpass
          *:*:*:$DB_USER:$DB_PW
          EOF
          chmod 0600 $HOME/.pgpass

- builder:
    name: mysql-db
    builders:
      - shell: |
          #!/bin/bash -xe
          DB_USER=openstack_citest
          DB_PW=openstack_citest
          mysql -u $DB_USER -p$DB_PW -h 127.0.0.1 -e "
              SET default_storage_engine=MYISAM;
              DROP DATABASE IF EXISTS {db_name};
              CREATE DATABASE {db_name} CHARACTER SET utf8;"

- builder:
    name: pgsql-db
    builders:
      - shell: |
          #!/bin/bash -xe
          DB_USER=openstack_citest
          DB_PW=openstack_citest
          psql -h 127.0.0.1 -U $DB_USER -d template1 -c "
              DROP DATABASE IF EXISTS {db_name}"
          createdb -h 127.0.0.1 -U $DB_USER -l C -T template0 -E utf8 {db_name}

- builder:
    name: static-publish-prep

    # We want to publish to the docroot but the scp publisher cannot remove
    # paths, so use a shell builder to move the content in the right place and
    # publish from there.
    builders:
      - shell: |
          #!/bin/bash -xe
          rm -rf ,content
          mv {source} ,content
          rm -rf .[^.]* [^,]*
          # Disable errexit here because there might not be any dotfiles.
          set +e
          mv ,content/.[^.]* ./
          set -e
          mv ,content/* ./
          rm -r ,content

- builder:
    name: install-buck
    builders:
      - shell: |
          #!/bin/bash -xe
          if [[ ! -d "buck" ]]
          then
            git clone https://gerrit.googlesource.com/buck
            cd buck
            ant
          fi


- builder:
    name: zuul-swift-upload
    builders:
      - shell: "/usr/zuul-swift-logs-env/bin/python /usr/local/jenkins/slave_scripts/zuul_swift_upload.py --name {zuul_log_instruction_set} {upload_source}"


- builder:
    name: zuul-swift-upload-logs
    builders:
      - zuul-swift-upload:
         zuul_log_instruction_set: logs
         upload_source: '{upload_source}'


- builder:
    name: zuul-swift-upload-console-log
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/grab_console_log.sh"
      - zuul-swift-upload-logs:
         upload_source: '/tmp/console.html'


- builder:
    name: zuul-swift-upload-logs-with-console
    builders:
      - shell: "/usr/local/jenkins/slave_scripts/grab_console_log.sh"
      - zuul-swift-upload-logs:
         upload_source: '{upload_source} /tmp/console.html'


- builder:
    name: print-node-uuid
    builders:
      - shell: |
          #!/bin/sh
          [ -f /etc/nodepool/uuid ] && echo "Node UUID: $(cat /etc/nodepool/uuid)"

- builder:
    name: build-openvswitch-docs
    builders:
      - shell: |
          #!/bin/sh
          cd src/{module}/build/
          make dist-docs

- builder:
    name: swagger-api
    builders:
      - shell: |
          #!/bin/bash -x
          set -e
          rm -rf $WORKSPACE/src/{depended-repo}
          git clone https://git.openswitch.net/openswitch/{depended-repo} $WORKSPACE/src/{depended-repo}
          rm -rf $WORKSPACE/src/ops-openvswitch
          git clone https://git.openswitch.net/openswitch/ops-openvswitch $WORKSPACE/src/ops-openvswitch
          cp /usr/local/jenkins/slave_scripts/inflect.py $WORKSPACE/src/ops-restd/opslib/
          cd $WORKSPACE/src/ops-restd/opslib
          mkdir -p $WORKSPACE/scp
          PYTHONPATH=../../ops-openvswitch/python python apidocgen.py ../../{depended-repo}/schema/vswitch.extschema ../../{depended-repo}/schema/vswitch.xml > $WORKSPACE/scp/{files}
          if [[ $? -ne 0 ]]; then
             exit 1
          else
             set +x
             echo "========== api doc generator ran succesfully, {files} is genereted =========="
          fi

# =====================================================================

- wrapper:
    name: build-timeout
    wrappers:
      - timeout:
          timeout: '{timeout}'
          timeout-var: 'BUILD_TIMEOUT'
          fail: true

# ======================================================================

- publisher:
    name: tarball
    publishers:
      - archive:
          artifacts: 'dist/*.tar.gz'
      - scp:
          site: '{site}'
          files:
            - target: 'tarballs/{project}/'
              source: 'dist/*.tar.gz'

- publisher:
    name: wheel
    publishers:
      - archive:
          artifacts: 'dist/*.whl'
      - scp:
          site: '{site}'
          files:
            - target: 'tarballs/{project}/'
              source: 'dist/*.whl'

- publisher:
    name: war
    publishers:
      - archive:
          artifacts: '{warfile}'
      - scp:
          site: '{site}'
          files:
            - target: '{target}'
              source: '{warfile}'

- publisher:
    name: console-log
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'logs/$LOG_PATH'
              copy-console: true
              copy-after-failure: true


- publisher:
    name: devstack-logs
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'logs/$LOG_PATH'
              source: 'logs/**'
              keep-hierarchy: true
              copy-after-failure: true


- publisher:
    name: coverage-log
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'logs/$LOG_PATH'
              source: 'cover/**'
              keep-hierarchy: true
              copy-after-failure: true

- publisher:
    name: coverage-log-ruby
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'logs/$LOG_PATH'
              source: 'coverage/**'
              keep-hierarchy: true
              copy-after-failure: true

- publisher:
    name: test-results
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'logs/$LOG_PATH'
              source: '**/*nose_results.html'
              keep-hierarchy: false
              copy-after-failure: true
            - target: 'logs/$LOG_PATH'
              source: '**/*testr_results.html.gz'
              keep-hierarchy: false
              copy-after-failure: true
            - target: 'logs/$LOG_PATH'
              source: '.testrepository/tmp*'
              keep-hierarchy: false
              copy-after-failure: true
            - target: 'logs/$LOG_PATH'
              source: '**/*subunit_log.txt.gz'
              keep-hierarchy: false
              copy-after-failure: true
            - target: 'logs/$LOG_PATH/tox'
              source: '.tox/*/log/*'
              keep-hierarchy: false
              copy-after-failure: true

- publisher:
    name: upload-sphinx-draft
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'docs-draft/$LOG_PATH'
              source: 'doc/build/html/**'
              keep-hierarchy: true
              copy-after-failure: true

- publisher:
    name: upload-docs-draft
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'docs-draft/$LOG_PATH/'
              source: 'publish-docs/**'
              keep-hierarchy: true
              copy-after-failure: true


- publisher:
    name: upload-to-docs-site
    publishers:
      - ftp:
          site: docs.openstack.org
          source: 'publish-docs/**'
          target: '/'
          remove-prefix: 'publish-docs/'

- publisher:
    name: upload-doc-build-results
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: 'logs/$LOG_PATH'
              source: 'build-*.log.gz'
              keep-hierarchy: false
              copy-after-failure: true

- publisher:
    name: zuul-swift-upload
    publishers:
      - postbuildscript:
          builders:
            - zuul-swift-upload:
                zuul_log_instruction_set: '{zuul_log_instruction_set}'
                upload_source: '{upload_source}'
          # These flags really mean only if on * when
          # checked. When both set to false the post script
          # should run on every job regardless of status.
          onfailure: False
          onsuccess: False

- publisher:
    name: zuul-swift-upload-logs
    publishers:
      - postbuildscript:
          builders:
            - zuul-swift-upload-logs:
                upload_source: '{upload_source}'
          # These flags really mean only if on * when
          # checked. When both set to false the post script
          # should run on every job regardless of status.
          onfailure: False
          onsuccess: False

- publisher:
    name: zuul-swift-upload-console-log
    publishers:
      - postbuildscript:
          builders:
            - zuul-swift-upload-console-log
          # These flags really mean only if on * when
          # checked. When both set to false the post script
          # should run on every job regardless of status.
          onfailure: False
          onsuccess: False

- publisher:
    name: zuul-swift-upload-logs-with-console
    publishers:
      - postbuildscript:
          builders:
            - zuul-swift-upload-logs-with-console:
                upload_source: '{upload_source}'
          # These flags really mean only if on * when
          # checked. When both set to false the post script
          # should run on every job regardless of status.
          onfailure: False
          onsuccess: False

- publisher:
    name: zuul-swift-devstack-logs-with-console
    publishers:
      - postbuildscript:
          builders:
            - shell: |
                #!/bin/bash -x
                cp devstack-gate/help/tempest-logs.html logs/index_footer.html
                mkdir zuul_swift_devstack_logs_extra
                cp devstack-gate/help/tempest-overview.html zuul_swift_devstack_logs_extra/index_footer.html
      - zuul-swift-upload-logs-with-console:
          upload_source: 'logs zuul_swift_devstack_logs_extra/index_footer.html'

- publisher:
    name: zuul-swift-test-results-with-console
    publishers:
      - zuul-swift-upload-logs-with-console:
          upload_source: '"**/*nose_results.html" "**/*testr_results.html.gz" ".testrepository/tmp*" "**/*subunit_log.txt.gz" ".tox/*/log/*"'

- publisher:
    name: simple-scp
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: '{dest}'
              source: 'scp/*.json'
              keep-hierarchy: true
              copy-after-failure: false

- publisher:
    name: governance-scp
    publishers:
      - scp:
          site: 'static.openswitch.net'
          files:
            - target: '{docroot}/'
              source: '**'
              keep-hierarchy: true
              copy-after-failure: false

- publisher:
    name: archive-syslog
    publishers:
      # Publish logs from tests if it is present
      - postbuildscript:
          builders:
            - shell: |
                 export TOPOLOGY_TEST_IMAGE=$(echo $JOB_NAME-$BUILD_NUMBER  | tr '[A-Z]' '[a-z]')
                 export SYSLOG="${TOPOLOGY_TEST_IMAGE}_syslog.txt"
                 sudo tail -n 2000 /var/log/syslog > build/$SYSLOG
          script-only-if-succeeded: False
          script-only-if-failed: True
      - conditional-publisher:
          - condition-kind: shell
            condition-command: ls build/*_syslog.txt
            on-evaluation-failure: dont-run
            action:
                - archive:
                    artifacts: 'build/*_syslog.txt'
                    allow-empty: 'true'

- publisher:
    name: post-ws-clean
    publishers:
      - workspace-cleanup:
         dirmatch: true
         include:
            - "*.*"
            - "*"
         clean-if:
            - success: true
            - unstable: true
            - not-built: true
            - aborted: true
            - failure: true
         fail-build: false

- publisher:
    name: archive-test-logs
    publishers:
      - conditional-publisher:
          - condition-kind: shell
            condition-command: test -d opsTest-results
            on-evaluation-failure: dont-run
            action:
                - archive:
                    artifacts: 'opsTest-results/**/*.log'
                    allow-empty: 'true'
      - conditional-publisher:
          - condition-kind: shell
            condition-command: test -d openswitch-test
            on-evaluation-failure: dont-run
            action:
                - archive:
                    artifacts: 'openswitch-test/**'
                    allow-empty: 'true'

- publisher:
    name: archive-test-logs-on-failure
    publishers:
      - conditional-publisher:
          - condition-kind: current-status
            condition-worst: FAILURE
            condition-best: UNSTABLE
            action:
                - archive:
                    artifacts: 'opsTest-results/**/*.log'
                    allow-empty: 'true'
                - archive:
                    artifacts: 'openswitch-test/**'
                    allow-empty: 'true'

- publisher:
    name: conditional-gather-test-results
    publishers:
      - conditional-publisher:
          - condition-kind: shell
            condition-command: ls build/test/*/test-results.xml > /dev/null
            on-evaluation-failure: dont-run
            action:
                - junit:
                    results: 'build/test/**/test-results.xml'

- publisher:
    name: conditional-junit
    publishers:
      - conditional-publisher:
          - condition-kind: shell
            condition-command: ls build/*test-results.xml
            on-evaluation-failure: dont-run
            action:
                - junit:
                    results: 'build/*test*.xml'
- publisher:
    name: conditional-htmlreports
    publishers:
      - conditional-publisher:
          - condition-kind: shell
            condition-command: ls coverage/html/index.html
            on-evaluation-failure: dont-run
            action:
                - html-publisher:
                    name: "Code Coverage Report"
                    dir: "coverage/html"
                    files: "index.html"
                    keep-all: true
                    allow-missing: true
                    link-to-last-build: true
- publisher:
    name: conditional-image-junit-to-archive
    publishers:
      - conditional-publisher:
          - condition-kind: shell
            condition-command: ls build/feature-test-results.xml
            on-evaluation-failure: dont-run
            action:
                - postbuildscript:
                    builders:
                        - shell: |
                            VERSION_STRING=$(cat .version_string)
                            rm -rf genericx86-64_autotestJunitResults/*; mkdir -p genericx86-64_autotestJunitResults
                            cp build/feature-test-results.xml genericx86-64_autotestJunitResults/
                            scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -r genericx86-64_autotestJunitResults static.openswitch.net:/srv/static/archive/artifacts/$TYPE/$VERSION_STRING/.

- publisher:
    name: mail-on-fail
    publishers:
       - email:
           recipients: '{email-by-space-when-fail}'

- publisher:
    name: mail-on-success
    publishers:
        - email-ext:
             recipients: '{email-by-comma-when-success}'
             content-type: html
             subject: "$PROJECT_DEFAULT_SUBJECT"
             body: "$PROJECT_DEFAULT_CONTENT"
             failure: false
             success: true
